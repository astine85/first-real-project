pipeline {
    agent any
    parameters {
        string(name: 'BRANCH', defaultValue: 'main', description: 'Branch to build from')
        string(name: 'REPO_URL', defaultValue: 'https://github.com/astine85/first-real-project.git', description: 'Repository URL to build from')
        string(name: 'VERSION', defaultValue: "V00${BUILD_ID}", description: 'Version of Docker image to be built, e.g., V001')
        string(name: 'TASK_DEF_JSON', defaultValue: 'continuous-integration-continuous-deployment/task-def.json', description: 'Path to the task definition JSON file')
        string(name: 'CREATE_SERVICE_FILE', defaultValue: 'continuous-integration-continuous-deployment/create-ecs-service.json', description: 'Path to the create service JSON file')
        string(name: 'UPDATE_SERVICE_FILE', defaultValue: 'continuous-integration-continuous-deployment/update-ecs-service.json', description: 'Path to the update service JSON file')
        string(name: 'SERVICE_NAME', defaultValue: 'first-real-project-ecs-service', description: 'ECS Service Name')
        string(name: 'ECS_CLUSTER_NAME', defaultValue: 'first-real-project-ecs-cluster', description: 'ECS Cluster Name')
        string(name: 'ECR_URI', defaultValue: '992382432814.dkr.ecr.us-east-1.amazonaws.com/first-real-project', description: 'ECR URI')
        string(name: 'IMAGE_NAME', defaultValue: 'first-real-project-app', description: 'Image Name')
        string(name: 'TARGET_GROUP_NAME', defaultValue: 'marketvector-tg', description: 'Target Group Name')
        string(name: 'VPC_ID', defaultValue: 'your-vpc-id', description: 'VPC ID') // Replace with your actual VPC ID
    }

    environment {
        GITHUB_CREDENTIAL = 'your-github-credentials-id' // Update with your actual credentials ID
    }

    stages {
        stage('Clean Workspace') {
            steps {
                cleanWs()
            }
        }

        stage('Clone GitHub Repo') {
            steps {
                git branch: "${params.BRANCH}", credentialsId: "${GITHUB_CREDENTIAL}", url: "${params.REPO_URL}"
            }
        }

        stage('Application Build And Test') {
            steps {
                sh 'chmod +x ./mvnw'
                sh './mvnw clean install'
                sh './mvnw test'
            }
        }

        stage('Building Docker Image') {
            steps {
                sh "docker build -t ${params.IMAGE_NAME}:${params.VERSION} ."
            }
        }

        stage('Push To Elastic Container Registry') {
            steps {
                script {
                    sh """
                    aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin ${params.ECR_URI}
                    docker tag ${params.IMAGE_NAME}:${params.VERSION} ${params.ECR_URI}:${params.VERSION}
                    docker push ${params.ECR_URI}:${params.VERSION}
                    """
                }
            }
        }

        stage('Check and Create Target Group') {
            steps {
                script {
                    // Check if the target group exists
                    def targetGroupArn = sh(script: """
                        aws elbv2 describe-target-groups --names ${params.TARGET_GROUP_NAME} --query 'TargetGroups[0].TargetGroupArn' --output text
                    """, returnStdout: true).trim()

                    if (targetGroupArn == "None") {
                        echo "Target group ${params.TARGET_GROUP_NAME} does not exist. Creating target group..."
                        targetGroupArn = sh(script: """
                            aws elbv2 create-target-group --name ${params.TARGET_GROUP_NAME} --protocol HTTP --port 8081 --vpc-id ${params.VPC_ID} --query 'TargetGroups[0].TargetGroupArn' --output text
                        """, returnStdout: true).trim()
                        echo "Created Target Group ARN: ${targetGroupArn}"
                    } else {
                        echo "Using existing Target Group ARN: ${targetGroupArn}"
                    }

                    // Update the create service JSON with the target group ARN
                    def createServiceJson = readFile(file: params.CREATE_SERVICE_FILE)
                    createServiceJson = createServiceJson.replaceAll(/"targetGroupArn": "[^"]+"/, "\"targetGroupArn\": \"${targetGroupArn}\"")
                    writeFile(file: params.CREATE_SERVICE_FILE, text: createServiceJson)
                }
            }
        }

        stage('Register Task Definition') {
            steps {
                script {
                    def taskDefArn = sh(script: """
                        aws ecs register-task-definition --cli-input-json file://${params.TASK_DEF_JSON} --query 'taskDefinition.taskDefinitionArn' --output text
                    """, returnStdout: true).trim()
                    echo "Registered Task Definition ARN: ${taskDefArn}"

                    // Update the update service JSON with the task definition ARN
                    def updateServiceJson = readFile(file: params.UPDATE_SERVICE_FILE)
                    updateServiceJson = updateServiceJson.replaceAll(/"taskDefinition": "arn:aws:ecs:[^"]+"/, "\"taskDefinition\": \"${taskDefArn}\"")
                    writeFile(file: params.UPDATE_SERVICE_FILE, text: updateServiceJson)
                }
            }
        }

        stage('Stop all running tasks') {
            steps {
                script {
                    def serviceExists = sh(script: """
                        aws ecs describe-services --cluster ${params.ECS_CLUSTER_NAME} --services ${params.SERVICE_NAME} --query "services[?status=='ACTIVE'].[serviceName]" --output text
                    """, returnStdout: true).trim()

                    if (serviceExists) {
                        echo "Stopping running tasks for service ${params.SERVICE_NAME}..."
                        sh """
                        tasks=\$(aws ecs list-tasks --cluster ${params.ECS_CLUSTER_NAME} --service-name ${params.SERVICE_NAME} --desired-status RUNNING --query taskArns --output text)
                        for task in \$tasks; do
                            aws ecs stop-task --cluster ${params.ECS_CLUSTER_NAME} --task \$task
                        done
                        """
                    } else {
                        echo "Service ${params.SERVICE_NAME} does not exist. Skipping stop tasks step."
                    }
                }
            }
        }

        stage('Wait for Tasks to Stop') {
            steps {
                script {
                    def serviceExists = sh(script: """
                        aws ecs describe-services --cluster ${params.ECS_CLUSTER_NAME} --services ${params.SERVICE_NAME} --query "services[?status=='ACTIVE'].[serviceName]" --output text
                    """, returnStdout: true).trim()

                    if (serviceExists) {
                        echo "Waiting for tasks to stop for service ${params.SERVICE_NAME}..."
                        timeout(time: 5, unit: 'MINUTES') {
                            waitUntil {
                                def tasks = sh(script: """
                                    aws ecs list-tasks --cluster ${params.ECS_CLUSTER_NAME} --service-name ${params.SERVICE_NAME} --desired-status RUNNING --query taskArns --output text
                                """, returnStdout: true).trim()

                                return tasks == null || tasks.isEmpty()
                            }
                        }
                    } else {
                        echo "Service ${params.SERVICE_NAME} does not exist. Skipping wait for tasks to stop step."
                    }
                }
            }
        }

        stage('Check and Update ECS Service') {
            steps {
                script {
                    def clientToken = UUID.randomUUID().toString()
                    sh """
                    SERVICE_EXISTS=\$(aws ecs describe-services --cluster ${params.ECS_CLUSTER_NAME} --services ${params.SERVICE_NAME} --query "services[?status=='ACTIVE'].[serviceName]" --output text)

                    if [ -z "\$SERVICE_EXISTS" ]; then
                      echo "Service ${params.SERVICE_NAME} does not exist. Creating service..."
                      aws ecs create-service --cli-input-json file://${params.CREATE_SERVICE_FILE} --client-token ${clientToken}
                    else
                      echo "Service ${params.SERVICE_NAME} exists. Updating service..."
                      aws ecs update-service --cli-input-json file://${params.UPDATE_SERVICE_FILE}
                    fi
                    """
                }
            }
        }
    }

    post {
        always {
            echo 'Pipeline completed.'
        }
        failure {
            echo 'Pipeline failed.'
        }
    }
}
